(ns com.sixsq.slipstream.auth.app.server
  (:require

    [clojure.tools.logging                                          :as log]
    [clojure.data.json                                              :as json]

    [org.httpkit.server                                             :refer [run-server]]
    [compojure.core                                                 :refer :all]
    [compojure.handler                                              :as handler]

    [ring.middleware.json                                           :refer [wrap-json-body wrap-json-response]]
    [ring.middleware.params                                         :refer [wrap-params]]
    [ring.middleware.cookies                                        :refer [wrap-cookies]]

    [com.sixsq.slipstream.auth.core                                 :as auth]
    [com.sixsq.slipstream.auth.simple-authentication                :as sa]
    [com.sixsq.slipstream.auth.app.http-utils                       :as hu]

    [com.sixsq.slipstream.auth.app.routes                           :refer :all]
    [com.sixsq.slipstream.auth.app.views.auth                       :as view] ))

(def authentication (sa/get-instance))

(defn deserialize
  [s]
  (log/info "deserializing " s)
  (let [res (json/read-str s :key-fn keyword)]
    (log/info "res " (class res) " : " res)
    res))

(defn- select-in-params
  [request keys]
  (-> request
      :params
      (select-keys keys)))

(defn- extract-credentials
  [request]
  (select-in-params request [:user-name :password]))

(defn extract-claims-token
  [request]
  (-> request
      (select-in-params [:claims :token])
      (update-in [:claims] deserialize)))

(defn add-user
  [request]
  (log/info "request" request)
  (let [credentials (extract-credentials request)]
    (log/info "Will add " (dissoc credentials :password))
    (auth/add-user! authentication credentials)
    (log/info "Done adding " (dissoc credentials :password))
    (view/registered-ok (:user-name credentials))))

(defn response-token-ok
  [token]
  (-> (hu/response 200)
      (assoc :cookies {"com.sixsq.slipstream.cookie" {:value token}})))

(defn response-invalid-token
  []
  (hu/response 401))

(defn log-result
  [credentials ok?]
  (log/info (str "'" (:user-name credentials) "' : "
                 (if ok? "login OK" "invalid password"))))

(defn login
  [request]
  (let [credentials (extract-credentials request)
        [ok? result] (auth/token authentication credentials)]
    (log-result credentials ok?)
    (if ok?
      (response-token-ok result)
      (response-invalid-token))))

(defn build-token
  [request]
  (log/info "Will build-token")
  (let [{:keys [claims token]}  (extract-claims-token request)
        [ok? result]            (auth/token authentication claims token)]
    (if ok?
      (hu/response-with-body 200 (:token result))
      (response-invalid-token))))

(defroutes app

  (GET  uri-register []             (view/register-form))
  (POST uri-register request        (add-user request))

  (GET  uri-login    []             (view/login))
  (POST uri-login    request        (login request))

  (POST uri-token    request        (build-token request)))

(defn- create-ring-handler
  []
  (log/info "creating ring handler")
  (-> app
      wrap-cookies
      wrap-params
      handler/site
      (wrap-json-body {:keywords? true})
      (wrap-json-response {:pretty true :escape-non-ascii true})))

(defn- start-container
  "Starts the http-kit container with the given ring application and
   on the given port.  Returns the function to be called to shutdown
   the http-kit container."
  [ring-app port]
  (log/info "starting the http-kit container on port" port)
  (run-server ring-app {:port port :ip "127.0.0.1"}))

(declare stop)

(defn- create-shutdown-hook
  [state]
  (proxy [Thread] [] (run [] (stop state))))

(defn register-shutdown-hook
  "This function registers a shutdown hook to close the database
   client cleanly and to shutdown the http-kit container when the
   JVM exits.  This only needs to be called in a context in which
   the stop function will not be explicitly called."
  [state]
  (let [hook (create-shutdown-hook state)]
    (.. (Runtime/getRuntime)
        (addShutdownHook hook))
    (log/info "registered shutdown hook")))

(defn start
  "Starts the server and returns a map with the application
   state containing the function to stop the http-kit container."
  [port]
  (let [ring-app (create-ring-handler)
        stop-fn (start-container ring-app port)
        state {:stop-fn stop-fn}]
    state))

(defn stop
  "Stops the http-kit container.  Takes the global state map
   generated by the start function as the argument."
  [{:keys [stop-fn]}]
  (log/info "shutting down http-kit container")
  (if stop-fn
    (stop-fn)))
